<!doctype html>
<html>
<head>
    <script>         
        const array1 = ['a', 'b', 'c'];

       // const iterator1 = array1.entries();

        //console.log(iterator1.next().value);
        // expected output: Array [0, "a"]

        //console.log(iterator1.next().value);
        // expected output: Array [1, "b"]
        
        //console.log(iterator1.next().value);
        
        keys = Object.keys(array1);        
        console.log(Object.keys(array1));
        for( key in keys) {
            console.log("Object key:",key);
            console.log("Object value:",array1[key]);            
        }
        
        /*values = Object.values(array1);        
        console.log(Object.values(array1));
        for( value in values)
            console.log("Object value:",values[value]);
        */
        
        
        
        /*iterator = array1.keys();
        console.log(iterator);
        console.log(iterator.length);
        //ie not available
        for ( key of iterator) {
          console.log('key:' + key);
        }*/
        
        /*console.log(Array.from('foo'));
        alert(Array(7));
        alert(Array.of(7));*/
        
        // prototype을 이용하면 객체의 toSting을 재정의(overriding)할 수 있다.
        // 다음 코드는 배열의 toString을 오버로딩해서 alert의 표시 값을 변경할수 있다.
        /*Array.prototype.toString = function(){
            var str = '';
            for(var i = 0; i < this.length; i++){
                str += i +':'+ this[i]+'\n';
            }
            return str;
        }
        var numbers = ['one', 'two', 'three', 'four', 'five'];
        alert(numbers.toString());
        alert(numbers); */
        
        /*var numbers = ['one', 'two', 'three', 'four', 'five'];
        alert(numbers.toString());
        alert(numbers);*/
        
        /*var numbers = [1,2,3,4,5,6,7,8,9,10];
        alert(numbers.splice(2)); // array, [3,4,5,6,7,8,9,10], 시작점 2부터 배열의 마지막 원소까지를 대상으로 한다.
        alert(numbers); // array, [1,2], 원본이 수정된다. 

        var numbers = [1,2,3,4,5,6,7,8,9,10];
        alert(numbers.splice(2, 4)); // array, [3,4,5,6]

        var numbers = [1,2,3,4,5,6,7,8,9,10];
        alert(numbers.splice(2, 4, 'three', 'four', 'five', 'six')); // array, [3,4,5,6]
        alert(numbers); // array, [1,2,three,four,five,six,7,8,9,10]*/
        
        /*var numbers = [9,8,7,6,5,4,3,2,1];
        alert(numbers.sort()); // array, [1,2,3,4,5,6,7,8,9]
        alert(numbers); // array, [1,2,3,4,5,6,7,8,9], 원본을 변경한다. 
        alert(numbers.sort() === numbers); // boolean, true, 원본과 반환값이 같다.

        var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
        //array, [1,10,2,20,3,4,5,6,7,8,9], 암시적으로 원소를 문자로 형변환 하기 때문에 10이 1뒤에 온다.
        alert(numbers.sort()); */
        
        /*function sortNumber(a,b){
            // 비교 대상인 a와 b가 인자로 전달된다.
            //alert('a :'+a+', b:'+b);
            // a에서 b를 뺀 결과가 음수면 a가 b보다 작고, 0이면 같다.
            // sort메소드는 return 값이 음수,양수,0인지에 따라서 순서를 정한다.
            //return a-b;
            
            // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
            return b-a;
        }
        var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
        alert(numbers.sort(sortNumber)); // array, [1,2,3,4,5,6,7,8,9,10,20]*/
        
        /*var jobs = ['programmer', 'designer', 'planner', 'sajang'];
        alert(jobs.slice(1,3)); // array, ['designer', 'planner'];
        alert(jobs.slice(3,1)); // undefined
        alert(jobs.slice(100)); // undefined 
        alert(jobs.slice(-2)); // array, ['planner', 'sajang'], 인자가 음수인 경우 시작점을 뒤에서부터 카운팅
        alert(jobs); // array, ['programmer', 'designer', 'planner', 'sajang'], 원본을 수정하지 않음*/

        
        /*var a = new Array(1,2,3);
        var b = new Array(4,5,6);
        var c = new Array(7,8,9);
        console.log(a.concat(b,c)); // [1,2,3,4,5,6,7,8,9]
        
        var a = new Array("welcome","coding","everybody");
        // join의 첫번째 인자로 ' '를 전달했기 때문에 반환 값은 원소와 원소 사이에 공백이 들어간 문자열이 반환된다.
        alert(a.join(' ')); // welcome coding everybody

        var jobs = ['programmer', 'designer', 'planner'];
        var job = jobs.pop();
        alert(job); // string, 'planner'
        alert(jobs); // array, ['programmer', 'designer'], 원본 jobs의 값이 변경 되었다.*/

/*        var a = new Array(1,2,3);
        var b = [1,2,3];
        var c = new Array();
        c.push(1);
        c.push(2);
        c.push(3);
        
        var a = new Array(1,2,3);
        for(var i=0; i<a.length; i++){
            alert(a[i]);
        }
        var a = new Array(new Number(5));
        alert(a);*/
        /*codingeverybody = new Array();
  
        codingeverybody['html'] = '웹문서를 만든다';
        codingeverybody['css'] = 'html을 꾸며준다';
        codingeverybody['javascript'] = 'html을 동적으로 제어한다';
        codingeverybody['php'] = 'html을 서버측에서 동적으로 생성한다';

        alert(codingeverybody['html']); // string, 웹문서를 만든다
        alert(codingeverybody['css']); // string, html을 꾸며준다
        
        codingeverybody.push(1);
        codingeverybody.push(2);

        alert(codingeverybody); // array, [1,2]
        console.log(codingeverybody); // number 2
        console.log(codingeverybody.length); // number 2
        console.log(codingeverybody.html)*/
        
    </script>
</head>
<body>
    
</body>
</html>